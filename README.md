Через 30 сек после начала, программа вызывает метод для загрузки классов.

Посмотрим на график Metaspace

![image](https://user-images.githubusercontent.com/65041919/177297607-7a511127-f067-4d43-b85e-3db05d3a986d.png)


На нем можно отчетливо увидеть момент начала загрузки классов (1)

Мы видим, что начинает увеличиваться Metaspace область памяти, которая как раз и хранит в себе всю информ. о загруженных
классах

Далее наша программа засыпает на некоторое время. Это тоже отчетливо видно на графике (1.1) Metaspace не увеличивается

Далее программа снова начинает загружать классы (2) снова увеличивается размер Metaspace, после чего снова небольшая
пауза программы (2.1)

И далее процедура повторяется (3) снова загрузка и затем пауза (3.1)

Также загрузку классов можно отследить на графике 2, на котором изображено в виде графика кол-во загруженных классов

![image](https://user-images.githubusercontent.com/65041919/177298206-dc10fe48-39d3-483e-9e3d-737575b9ebb9.png)


Если посмотреть на оранжевую легенду, то можно увидеть  фазы роста 1-2-3 как раз столько раз наш метод загрузки классов и
вызывался

Далее наша программа переходит к созданию объектов.

![image](https://user-images.githubusercontent.com/65041919/177298661-bbe374c6-2110-4852-a35f-9f9cc41fe51b.png)

На данном графике у нас 2 легенды. Оранжевая - размер кучи и синяя - использование памяти. В момент запуска метода для
создания объектов, на графике резко возрастает используемая кучей память (1), что как раз и свидетельствует о том, что
наши объекты создались и поместились в кучу. Также заметим, что при увеличении потребляемой кучей памяти, JVM
увеличивает максимальную память кучи.

Далее небольшое затишье, после чего повторно создаются объекты, и мы снова наблюдаем увеличение потребляемой кучей
памяти(2) (в этот раз запас памяти кучи не увеличивается)

Далее снова небольшая пауза

И вновь создаем объекты (3). Видим что JVM снова увеличивает память кучи

Если посмотреть на график CPU/GC можно пронаблюдать работу цп и сборщика мусора.

![image](https://user-images.githubusercontent.com/65041919/177299160-9f669e1c-7405-4d49-9084-a888e8215db8.png)


Видим, что при загрузке классов(1,2,3) работает цп, сборщик мусора не работает(логично, объекты не создаются)

Далее, при каждой волне создании объектов (4,5,6) запускается сборщик мусора (4.1,5.1,6.1). Если бы память, выделенная
для кучи, была бы сильно больше используемой кучей памяти, то после запуска сборщика мусора, JVM уменьшила бы "запасную"
память для кучи 


